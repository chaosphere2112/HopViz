<!DOCTYPE html>
<html>
	<head>
		<script type="text/javascript" src="json/hops.json"></script>
		<script type="text/javascript" src="lib/d3.min.js"></script>
		<script type="text/javascript" src="lib/svg-pan-zoom.min.js"></script>
		<style>
			.styles {
				float: left;
				width:200px	;
			}
			.choose-hop>h3 {
				display: inline-block;
			}
			.title {
				display: inline-block;
				margin-right: 1em;
			}
			.subtitle {
				display: inline-block;
			}
			.details {
				float: right;
				width: 200px;
				overflow-y: scroll;
			}
			.vizframe {
			}
			#viz {
				float:left;
			}
			.hop {
				cursor: pointer;
			}
		</style>
	</head>
	<body>
		<div class="vizframe">
			<div class="choose-hop">
				<h3>Select a Hop:</h3>
				<select class="hoplist">
					<option value="null">--</option>
				</select>
				<button class="reset">Reset</button>
			</div>
			<div class="styles">
				<h3>Styles</h3>
				<form id="style_checkboxes">
				</form>
			</div>
			<svg id="viz"></svg>
			<div class="details">
				<h4 class="name"></h4>
				<p class="notes"></p>
				<h5>Styles</h5>
				<svg class="stylechart"></svg>
				<h5>Pairings</h5>
				<svg class="pairchart"></svg>
			</div>
		</div>
		<script>
			function variance(l) {
				function mean(l) {
					return l.reduce(function(previous, current) { return previous + current; }, 0) / l.length;
				}
				var l_mean = mean(l);
				var square_diff = l.map(function(d) { return Math.pow(d - l_mean, 2); });
				return mean(square_diff);
			}

			function map_obj(obj, func) {
				var values = []
				for (var key in obj) {
					if (obj.hasOwnProperty(key) === false) {
						continue;
					}
					values.push(func(obj[key], key));
				}
				return values;
			}

			// Used to determine which styles we're looking at and which we aren't
			var styles = {
				"Light Lager": true,
				"Pilsner": true,
				"European Amber Lager": true,
				"Dark Lager": true,
				"Bock": true,
				"Light Hybrid Beer": true,
				"Amber Hybrid Beer": true,
				"English Pale Ale": true,
				"Scottish and Irish Ale": true,
				"American Ale": true,
				"English Brown Ale": true,
				"Porter": true,
				"Stout": true,
				"India Pale Ale": true,
				"Wheat and Rye Beer": true,
				"Belgian and French Ale": true,
				"Sour Ale": true,
				"Belgian Strong Ale": true,
				"Strong Ale": true,
				"Fruit Beer": true,
				"Spice/Herb/Vegetable Beer": true,
				"Smoke & Wood-Aged Beer": true,
				"Specialty Beer": true
			}

			var stylelist = map_obj(styles, function(d, key) { return key; });

			function active_styles(){
				var active = [];
				map_obj(styles, function(val, key) { if (val === true) { active.push(key); } });
				return active;
			}

			function hop_pairings(hop) {
				var styles = active_styles();
				var style, pairs;
				pairings = {}
				for (var i = 0; i < styles.length; i++) {
					style = styles[i];
					pairs = hop.pairings[style];
					map_obj(pairs, function (val, key) {
						if (pairings.hasOwnProperty(key)) {
							pairings[key] += val;
						} else {
							pairings[key] = val;
						}
					});
				}
				return pairings;
			}

			// Use as base space size
			var unit = 50;
			var width = 800; height = 500;
			var hops = hop_data;

			hops.sort(function(a, b) { return b.count - a.count; });

			var colormap = []
			var hue = 136, sat = 100, light = 42;
			var pct = 0;
			var tmpsat, tmplight;
			var minsat = 42, maxlight = 80;
			var minsize = unit / 4, maxsize = unit / 2;
			var sizemap = [];
			// Use the max count as the upper end of the colormap
			for (var i = 0; i <= hops[0].count; i++) {
				pct = i / hops[0].count;
				tmpsat = minsat + (sat - minsat) * pct;
				tmplight = maxlight - (maxlight - light) * pct;
				colormap.push("hsl(" + hue + ", " + tmpsat + "%, " + tmplight + "%)");
				sizemap.push(minsize + (maxsize - minsize) * pct);
			}

			// Determine cx, cy, r, and (eventually) color
			var hop_attrs = hops.map(function(hop, index) {
				var cx, cy, r;

				r = unit / 2;
				// Position is derived from index and pairings
				var num_cols = width / unit;
				var num_rows = height / unit;

				var col = index % num_cols;
				var row = Math.floor(index / num_cols);

				cx = col * unit + r;
				cy = row * unit + r;

				return {
					"name": hop.name,
					"pairings": hop.pairings,
					"count": hop.count,
					"cx": cx,
					"cy": cy,
					"r": sizemap[hop.count],
					"color": colormap[hop.count]
				}
			});

			var svg = d3.select("body>.vizframe>#viz").attr('width', width).attr("height", height);
			var circles = svg.selectAll("circle")
			   .data(hop_attrs)
			   .enter()
			   .append("circle");
			
			var filter = null;

			function build_bar(root, data, width, height) {
				root.attr("width", width)
					.attr("height", height);
				var key, count = 0, values = [], keys=[];
				
				map_obj(data, function(val, key) {
					values.push(val);
					keys.push(key);
					count += 1;
				});

				var x = d3.scale.linear()
									 .domain([0, d3.max(values)])
									 .range([0, width]);
				var bar_height = height / count;
				var bar = root.selectAll("g")
							  .data(values)
							  .enter()
							  .append("g")
							  .attr("transform", function(d, i) { return "translate(0," + i * bar_height + ")"; });
				bar.append("rect")
				   .attr("width", x)
				   .attr("height", bar_height - 1);
				bar.append('text')
				   .attr("x", function(d) { return x(d) - 3; })
				   .attr("y", bar_height / 2)
				   .attr("dy", ".35em")
				   .text(function(d) { return d; });
				bar.append('text')
				   .attr('x', 0)
				   .attr('y', bar_height / 2)
				   .attr('dy', ".35em")
				   .text(function(d, i) { return keys[i]; });
			}

			//build_bar(d3.select("body>.vizframe>.details>.pairchart"), hop_attrs[0].pairings, 200, 1000);

			function filterhops(hop) {
				var unused, unused, target, pairs;
				
				if (filter !== null) {
					target = circles.filter(function(el) { return el.name === filter.name});
					target.attr("stroke-width", 2);
				}
				// Determine which hops to keep and which to shove off to the sides
				if (hop === null || filter === hop.name) {
					filter = null;
					used = circles;
					unused = d3.selectAll([]);
					target = d3.selectAll([]);
					hoplist.property("value", "null");
					pairs = {};
				} else {
					filter = hop.name;
					pairs = hop_pairings(hop);
					unused = circles.filter(function(el) { return el.name !== hop.name && pairs.hasOwnProperty(el.name) === false; });
					used = circles.filter(function(el) {
						return pairs.hasOwnProperty(el.name);
					});
					target = circles.filter(function(el) { return el.name == hop.name; });
					var alpha_obj = list_items.filter(function(el) { return el.name == hop.name; });
					hoplist.property("value", alpha_obj.attr('value'));
				}
				unused.transition()
					  .attr('cx', function(d) { return -d.r; })
					  .attr("cy", function(d) { return -d.r; })

				target.transition()
					  .attr('cx', width / 2)
					  .attr('cy', height / 2)
					  .attr('stroke-width', 3);

				if (filter === null) {
					used.transition()
						.attr('cx', function(d) { return d.cx; })
					    .attr("cy", function(d) { return d.cy; })
					    .attr("stroke-width", 2);
					return;
				}

				// Retrieve paired hops
				var paired_hops = hop_attrs.filter(function(d) { return pairs.hasOwnProperty(d.name); });
				// Sort by pairing freq
				paired_hops = paired_hops.sort(function(a, b) { 
					return pairs[a.name] - pairs[b.name];
				});

				var levels = {};
				var level_vals = [];
				// Get max freq
				var maxfreq = 0;
				// Get min freq
				var minfreq = null;

				function log_ish(v) {
					return Math.max(Math.log(v), .01);
				}

				paired_hops.map(function(d){
					if (pairs[d.name] > maxfreq) {
						maxfreq = pairs[d.name];
					}
					if (minfreq === null || pairs[d.name] < minfreq) {
						minfreq = pairs[d.name];
					}
					var level = Math.ceil(log_ish(pairs[d.name]));
					if (!levels.hasOwnProperty(level)) {
						levels[level] = [];
						level_vals.push(level);
					}
					levels[level].push(d.name);
					return {};
				});
				level_vals = level_vals.sort();
				var maxdistance = Math.min(width / 2, height / 2);
				var maxlog = log_ish(maxfreq);
				// Determine distance for each hop
				function dist(d) {
					var maxdist = maxdistance - hop.r - d.r;

					return maxdist - (maxdist * log_ish(pairs[d.name]) / maxlog) + hop.r + d.r;
				}

				// Determine theta for each hop
				function theta(d) {
					var level = Math.ceil(log_ish(pairs[d.name]));
					var index = levels[level].indexOf(d.name);
					return 2 * Math.PI / levels[level].length * index + (2 * Math.PI / level_vals.length * level_vals.indexOf(level));
				}

				used.transition()
				    .attr("cx", function(d, i) {
				    	return Math.cos(theta(d)) * dist(d) + width / 2;
				    })
				    .attr("cy", function(d, i) {
				    	return Math.sin(theta(d)) * dist(d) + height / 2;
				    })
				    .attr("stroke-width", 2);

			}

			var circle_attrs = circles.attr("class", "hop")
									  .attr("cx", function(d) { return d.cx; })
									  .attr("cy", function(d) { return d.cy; })
									  .attr("r", function(d) { return d.r; })
									  .attr("fill", function(d) { return d.color; })
									  .attr('stroke', "#008523")
									  .attr("stroke-width", 2)
									  .on("click", function(d, i) {
									  	filterhops(d);
									  })
									  .on("mouseover", function(d, i) {
										d3.select(this).transition().attr("r", 1.1 * d.r);
										d3.select("#hopname").text(d.name);
									  })
									  .on("mouseout", function(d, i) {
									  	d3.select(this).transition().attr("r", d.r);
									  });
			var alphahops = hop_attrs.concat().sort(function(a, b) { return a.name.localeCompare(b.name); });
			var hoplist = d3.select("body>.vizframe>.choose-hop>.hoplist");
			var list_items = hoplist.on("change", function(){
										var ind = this.selectedIndex;
										if (ind === 0) {
											filterhops(null);
										} else {
									    	filterhops(alphahops[this.selectedIndex - 1]);
									    }
									})
									.selectAll("li.hoption")
									.data(alphahops)
									.enter()
									.append("option")
									.attr("class", "hoption")
									.text(function(d) { return d.name +" (" + d.count + ")"; })
									.attr('value', function(d, i) { return i; });

			var style_divs = d3.select("body>.vizframe>.styles>#style_checkboxes").selectAll("div").data(stylelist).enter().append("div");
			style_divs.append("input").attr("type", "checkbox").attr('data-style', function(d) { return d; }).attr("id", function(d, i) { return "style" + i; }).property('checked', function(d, i) { return styles[d]; }).on("change", function() { var style = this.dataset.style; styles[style] = this.checked; });
			style_divs.append("label").attr("for", function(d, i) { return "style" + i; }).text(function(d) { return d; });

			d3.select("body>.vizframe>.choose-hop>.reset").on("click", function() { filterhops(null); });
		</script>
	</body>
</html>
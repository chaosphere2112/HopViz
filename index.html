<!DOCTYPE html>
<html>
	<head>
		<script type="text/javascript" src="json/hops.json"></script>
		<script type="text/javascript" src="lib/d3.min.js"></script>
		<script type="text/javascript" src="lib/svg-pan-zoom.min.js"></script>
		<script type="text/javascript" src="scripts/bars.js"></script>
		<script type="text/javascript" src="scripts/colors.js"></script>
		<style>
			.styles {
				float: left;
				width:200px	;
			}
			.choose-hop>h3 {
				display: inline-block;
			}
			.title {
				display: inline-block;
				margin-right: 1em;
			}
			.subtitle {
				display: inline-block;
			}
			.details {
				float: right;
				width: 200px;
				overflow-y: scroll;
			}
			.vizframe {
			}
			#viz {
				float:left;
			}
			.hop {
				cursor: pointer;
			}
			.bar {
				fill: blue;
			}
		</style>
	</head>
	<body>
		<div class="vizframe">
			<div class="choose-hop">
				<h3>Select a Hop:</h3>
				<select class="hoplist">
					<option value="null">--</option>
				</select>
				<button class="reset">Reset</button>
			</div>
			<div class="styles">
				<h3>Styles</h3>
				<form id="style_checkboxes">
				</form>
			</div>
			<svg id="viz">
				<g id="hop_group"></g>
				<text id="hoverlabel" x="-100" y="-100"></text>
			</svg>
			<div class="details">
				<h4 class="name"></h4>
				<p class="notes"></p>
				<h5>Style Distribution</h5>
				<svg class="stylechart"></svg>
				<h5>Pairings</h5>
				<svg class="pairchart"></svg>
			</div>
		</div>
		<script>

			//todo: group styles and have "check all" / "uncheck all"
			//todo: details section

			// variable hops included from hops.json
			// Use as base space size
			var unit = 50;
			var width = 800; height = 500;
			var rows = Math.ceil(Math.sqrt(hops.length));
			var cols = Math.ceil(hops.length / rows);

			function variance(l) {
				function mean(l) {
					return l.reduce(function(previous, current) { return previous + current; }, 0) / l.length;
				}
				var l_mean = mean(l);
				var square_diff = l.map(function(d) { return Math.pow(d - l_mean, 2); });
				return mean(square_diff);
			}

			function map_obj(obj, func) {
				var values = []
				for (var key in obj) {
					if (obj.hasOwnProperty(key) === false) {
						continue;
					}
					values.push(func(obj[key], key));
				}
				return values;
			}

			// Used to determine which styles we're looking at and which we aren't
			var styles = {
				"Light Lager": true,
				"Pilsner": true,
				"European Amber Lager": true,
				"Dark Lager": true,
				"Bock": true,
				"Light Hybrid Beer": true,
				"Amber Hybrid Beer": true,
				"English Pale Ale": true,
				"Scottish and Irish Ale": true,
				"American Ale": true,
				"English Brown Ale": true,
				"Porter": true,
				"Stout": true,
				"India Pale Ale": true,
				"Wheat and Rye Beer": true,
				"Belgian and French Ale": true,
				"Sour Ale": true,
				"Belgian Strong Ale": true,
				"Strong Ale": true,
				"Fruit Beer": true,
				"Spice/Herb/Vegetable Beer": true,
				"Smoke & Wood-Aged Beer": true,
				"Specialty Beer": true
			}

			var stylelist = map_obj(styles, function(d, key) { return key; });

			function active_styles(){
				var active = [];
				map_obj(styles, function(val, key) { if (val === true) { active.push(key); } });
				return active;
			}

			function hop_pairings(hop) {
				var styles = active_styles();
				var style, pairs;
				pairings = {}
				for (var i = 0; i < styles.length; i++) {
					style = styles[i];
					pairs = hop.pairings[style];
					map_obj(pairs, function (val, key) {
						if (pairings.hasOwnProperty(key)) {
							pairings[key] += val;
						} else {
							pairings[key] = val;
						}
					});
				}
				return pairings;
			}

			function hop_count(hop) {
				var styles = active_styles();
				return styles.reduce(function(count, style) {
					if (hop.count.hasOwnProperty(style)) {
						return count + hop.count[style];
					} else {
						return count;
					}
				}, 0);
			}

			function hop_by_name(hopname) {
				return hops.filter(function(d) { return hopname === d.name; })[0];
			}

			function filtered_hops() {
				var filtered = hops.filter(function(d) { return hop_count(d) > 0; });
				return filtered;
			}

			function style_counts(hop) {
				var hops;
				var styles = active_styles();
				if (hop === null) {
					hops = filtered_hops();
				} else {
					hops = [hop];
				}
				var counts = styles.map(function(style) {
					return hops.reduce(function(val, hop){
						if (hop.count.hasOwnProperty(style)) {
							return val + hop.count[style];
						} else {
							return val;
						}
					}, 0);
				});
				return styles.reduce(function(obj, style, ind) { obj[style] = counts[ind]; return obj; }, {});
			}
			

			hops.sort(function(a, b) { return hop_count(b) - hop_count(a); });

			var colormap = []
			var hue = 136, sat = 100, light = 42;
			var pct = 0;
			var tmpsat, tmplight;
			var minsat = 42, maxlight = 80;
			var minsize = unit / 4, maxsize = unit / 2;
			var sizemap = [];
			// Use the max count as the upper end of the colormap
			for (var i = 0; i <= hop_count(hops[0]); i++) {
				pct = i / hop_count(hops[0]);
				tmpsat = minsat + (sat - minsat) * pct;
				tmplight = maxlight - (maxlight - light) * pct;
				colormap.push("hsl(" + hue + ", " + tmpsat + "%, " + tmplight + "%)");
				sizemap.push(minsize + (maxsize - minsize) * pct);
			}

			var svg = d3.select("body>.vizframe>#viz").attr('width', width).attr("height", height);
			var circles = svg.select("#hop_group").selectAll("circle")
								.data(hops)
								.enter()
								.append("circle");

			var filter = null;
			//build_bar(d3.select("body>.vizframe>.details>.pairchart"), hop_attrs[0].pairings, 200, 1000);
			// Reset at every update()
			var max_pairs = 0;
			var pair_levels = {};
	
			function distance(d, i) {
				var pairs = hop_pairings(filter);
				var pair_count = pairs[d.name];

				var maxdistance = Math.max(width / 2, height / 2) / 2 - r(d);

				if (max_pairs == 0 || max_pairs == 1) {
					if (pair_count == 1) {
						pair_count = 1.1;
					}
					max_pairs = 1.1;
				}
				var logpct = Math.log(pair_count) / Math.log(max_pairs)

				return maxdistance - maxdistance * logpct + r(filter) + r(d);
			}

			function angle(d, i) {
				var pairs = hop_pairings(filter);
				var pair_count = pairs[d.name];
				var pair_level = Math.ceil(Math.log(pair_count));
				return pair_levels[pair_level].indexOf(d.name) * 2 * Math.PI / pair_levels[pair_level].length;
			}


			function cx(d, i) {
				if (filter === null) {
					if (hop_count(d) > 0) {
						// Display in rows across the canvas
						return i % cols * Math.ceil(width / cols) + unit / 2;
					} else {
						// Hide offscreen
						return -1 * r(d);
					}
				} else {
					if (filter === d) {
						return width / 2;
					} 

					var pairs = hop_pairings(filter);
					if (pairs.hasOwnProperty(d.name)) {
						return distance(d, i) * Math.cos(angle(d, i)) + width / 2;
					} else {
						return -1 * r(d);
					}
				}

			}

			function cy(d, i) {
				if (filter === null) {
					if (hop_count(d) > 0) {
						// Display in rows across the canvas
						return Math.floor(i / rows) * Math.ceil(height / rows) + unit / 2;
					} else {
						// Hide offscreen
						return -1 * r(d);
					}
				} else {
					if (filter === d) {
						return height / 2;
					}

					var pairs = hop_pairings(filter);
					if (pairs.hasOwnProperty(d.name)) {
						return distance(d, i) * Math.sin(angle(d, i)) + height / 2;
					} else {
						return -1 * r(d);
					}
				}
			}

			function r(d) {
				var count = hop_count(d);
				if (count > 0) {
					if (count > sizemap.length - 1) {
						return sizemap[sizemap.length - 1];
					}
					return sizemap[count];
				} else {
					return 1;
				}
			}

			function stroke_width(d) {
				if (filter === d) {
					return 4;
				} else {
					return 2;
				}
			}

			function fill(d, i) {
				return colors[i];
			}

			var alphahops = hops.concat().sort(function(a, b) { return a.name.localeCompare(b.name); });
			var hoplist = d3.select("body>.vizframe>.choose-hop>.hoplist");
			var list_items = hoplist.selectAll("li.hoption")
									.data(alphahops)
									.enter()
									.append("option")
									.attr("class", "hoption")
									.text(function(d) { return d.name +" (" + hop_count(d) + ")"; })
									.attr('value', function(d, i) { return i; });
			function update() {

				max_pairs = 0;
				pair_levels = {};

				styles_data = style_counts(filter);
				build_bar(d3.select("body>.vizframe>.details>.stylechart"), styles_data, 300, 25);
				
				if (filter === null) {
					hoplist.property("value", "null");
					d3.select(".details>.name").text("");
					d3.select(".details>.notes").text("");

				} else {
					hoplist.property("value", alphahops.indexOf(filter));
					// Gather useful info for distance/angle
					map_obj(hop_pairings(filter), function(value, key) {
						if (value > max_pairs) {
							max_pairs = value;
						}
						var log = Math.ceil(Math.log(value));
						if (pair_levels.hasOwnProperty(log)) {
							pair_levels[log].push(key);
						} else {
							pair_levels[log] = [key];
						}
					});

					d3.select(".details>.name").text(filter.name);
					d3.select(".details>.notes").text(filter.notes);

				}

				// Update the sizemap
				var maxcount = hops.reduce(function(value, hop ) {
					return Math.max(hop_count(hop), value);
				}, 0);
				sizemap = [];
				var pct = 0;
				for (var i = 0; i <= maxcount; i++) {
					pct = i / maxcount;
					sizemap.push(minsize + (maxsize - minsize) * pct);
				}

				circles.transition()
						.attr("cx", cx)
						.attr("cy", cy)
						.attr("r", r)
						.attr("stroke-width", stroke_width);

				list_items.text(function(d) { return d.name + " (" + hop_count(d) + ")"; });
				if (filter !== null) {
					hoverlabel.transition().attr('x', cx(filter, hops.indexOf(filter))).attr("y", cy(filter, hops.indexOf(filter)));
				}
			}

			hoplist.on("change", function(){
				var ind = this.selectedIndex;
				if (ind === 0) {
					filter = null;
				} else {
					filter = alphahops[this.selectedIndex - 1];
				}
				update();
			});

			var label_timer = null;
			var hoverlabel = svg.select("#hoverlabel")
								.on("mouseover", cancel_label_hide)
								.on("mouseout", start_hide_label)
								.on("click", function(d, i) {
									if (filter === label_hovering) {
										filter = null;
									} else {
										filter = label_hovering;
									}
									update();
								});
			var label_hovering = null;

			function cancel_label_hide(){
				if (label_timer !== null) {
					window.clearTimeout(label_timer);
					label_timer = null;
				}
			}
			function start_hide_label() {
				label_timer = window.setTimeout(function(){
					hoverlabel.attr('x', -1000).attr('y', -1000);
					label_hovering = null;
				}, 300);
			}

			circles.attr("class", "hop")
					.attr("data-name", function(d) { return d.name; })
					.attr("fill", fill)
					.attr('stroke', "#008523")
					.attr("stroke-width", stroke_width)
					.on("click", function(d, i) {
						if (filter === d) {
							filter = null;
						} else {
							filter = d;
						}
						update();
					})
					.on("mouseover", function(d, i) {
						cancel_label_hide();
						label_hovering = d;
						svg.select("#hoverlabel").text(d.name).attr("x", cx(d, i)).attr("y", cy(d, i));
					})
					.on("mouseout", function(d, i) {
						start_hide_label();
					});


			update();

			var style_divs = d3.select("body>.vizframe>.styles>#style_checkboxes").selectAll("div").data(stylelist).enter().append("div");
			style_divs.append("input")
						.attr("type", "checkbox")
						.attr('data-style', function(d) { return d; })
						.attr("id", function(d, i) { return "style" + i; })
						.property('checked', function(d, i) { return styles[d]; })
						.on("change", function() {
							var style = this.dataset.style;
							styles[style] = this.checked;
							update();
						});
			style_divs.append("label").attr("for", function(d, i) { return "style" + i; }).text(function(d) { return d; });

			d3.select("body>.vizframe>.choose-hop>.reset").on("click", function() { filterhops(null); });
		</script>
	</body>
</html>
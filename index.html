<!DOCTYPE html>
<html>
	<head>
		<script type="text/javascript" src="json/hops.json"></script>
		<script type="text/javascript" src="lib/d3.min.js"></script>
		<script type="text/javascript" src="lib/svg-pan-zoom.min.js"></script>
		<style>
			.styles {
				float:left;
			}
			.hop-choice {
				cursor: pointer;
			}
			.choose-hop>h3 {
				display: inline-block;
			}
		</style>
	</head>
	<body>
		<div class="vizframe">
			<h1 class="title">Homebrew Hops</h1>
			<h2 class="subtitle">Hop pairings used by homebrewers around the world</h2>
			<div class="choose-hop">
				<h3>Select a Hop:</h3>
				<select class="hoplist">
					<option value="null">--</option>
				</select>
				<button class="reset">Reset</button>
			</div>
			<div class="styles">
				<h3>Styles</h3>
			</div>
			<svg id="viz"></svg>
		</div>
		<script>
			function variance(l) {
				function mean(l) {
					return l.reduce(function(previous, current) { return previous + current; }, 0) / l.length;
				}
				var l_mean = mean(l);
				var square_diff = l.map(function(d) { return Math.pow(d - l_mean, 2); });
				return mean(square_diff);
			}

			// Use as base space size
			var unit = 50;
			var width = 800; height = 500;
			var hops = hop_data;

			hops.sort(function(a, b) { return b.count - a.count; });

			var colormap = []
			var hue = 136, sat = 100, light = 42;
			var pct = 0;
			var tmpsat, tmplight;
			var minsat = 42, maxlight = 80;
			var minsize = unit / 4, maxsize = unit / 2;
			var sizemap = [];
			// Use the max count as the upper end of the colormap
			for (var i = 0; i <= hops[0].count; i++) {
				pct = i / hops[0].count;
				tmpsat = minsat + (sat - minsat) * pct;
				tmplight = maxlight - (maxlight - light) * pct;
				colormap.push("hsl(" + hue + ", " + tmpsat + "%, " + tmplight + "%)");
				sizemap.push(minsize + (maxsize - minsize) * pct);
			}

			// Determine cx, cy, r, and (eventually) color
			var hop_attrs = hops.map(function(hop, index) {
				var cx, cy, r;

				r = unit / 2;
				// Position is derived from index and pairings
				var num_cols = width / unit;
				var num_rows = height / unit;

				var col = index % num_cols;
				var row = Math.floor(index / num_cols);

				cx = col * unit + r;
				cy = row * unit + r;

				return {
					"name": hop.name,
					"pairings": hop.pairings,
					"count": hop.count,
					"cx": cx,
					"cy": cy,
					"r": sizemap[hop.count],
					"color": colormap[hop.count]
				}
			});

			var svg = d3.select("body>.vizframe>#viz").attr('width', width).attr("height", height);
			var circles = svg.selectAll("circle")
			   .data(hop_attrs)
			   .enter()
			   .append("circle");
			
			var filter = null;

			function filterhops(hop) {
				var unused, unused, target;
				
				if (filter !== null) {
					target = circles.filter(function(el) { return el.name === filter.name});
					target.attr("stroke-width", 2);
				}
				// Determine which hops to keep and which to shove off to the sides
				if (hop === null || filter === hop.name) {
					filter = null;
					used = circles;
					unused = d3.selectAll([]);
					target = d3.selectAll([]);
					hoplist.property("value", "null");
				} else {
					filter = hop.name;
					unused = circles.filter(function(el) { return el.name !== hop.name && hop.pairings.hasOwnProperty(el.name) === false; });
					used = circles.filter(function(el) {
						return hop.pairings.hasOwnProperty(el.name);
					});
					target = circles.filter(function(el) { return el.name == hop.name; });
					var alpha_obj = list_items.filter(function(el) { return el.name == hop.name; });
					hoplist.property("value", alpha_obj.attr('value'));
				}

				unused.transition()
					  .attr('cx', function(d) { return -d.r; })
					  .attr("cy", function(d) { return -d.r; })

				target.transition()
					  .attr('cx', width / 2)
					  .attr('cy', height / 2)
					  .attr('stroke-width', 3);

				if (filter === null) {
					used.transition()
						.attr('cx', function(d) { return d.cx; })
					    .attr("cy", function(d) { return d.cy; })
					return;
				}

				// Retrieve paired hops
				var paired_hops = hop_attrs.filter(function(d) { return hop.pairings.hasOwnProperty(d.name); });
				// Sort by pairing freq
				paired_hops = paired_hops.sort(function(a, b) { return hop.pairings[a.name] - hop.pairings[b.name]; });

				var levels = {};
				var level_vals = [];
				// Get max freq
				var maxfreq = 0;
				// Get min freq
				var minfreq = null;

				function log_ish(v) {
					return Math.max(Math.log(v), .01);
				}

				paired_hops.map(function(d){
					if (hop.pairings[d.name] > maxfreq) {
						maxfreq = hop.pairings[d.name];
					}
					if (minfreq === null || hop.pairings[d.name] < minfreq) {
						minfreq = hop.pairings[d.name];
					}
					var level = Math.ceil(log_ish(hop.pairings[d.name]));
					if (!levels.hasOwnProperty(level)) {
						levels[level] = [];
						level_vals.push(level);
					}
					levels[level].push(d.name);
					return {};
				});
				level_vals = level_vals.sort();
				var maxdistance = Math.min(width / 2, height / 2);
				var maxlog = log_ish(maxfreq);
				// Determine distance for each hop
				function dist(d) {
					var maxdist = maxdistance - hop.r - d.r;

					return maxdist - (maxdist * log_ish(hop.pairings[d.name]) / maxlog) + hop.r + d.r;
				}

				// Determine theta for each hop
				function theta(d) {
					var level = Math.ceil(log_ish(hop.pairings[d.name]));
					var index = levels[level].indexOf(d.name);
					return 2 * Math.PI / levels[level].length * index + (2 * Math.PI / level_vals.length * level_vals.indexOf(level));
				}

				used.transition()
				    .attr("cx", function(d, i) {
				    	return Math.cos(theta(d)) * dist(d) + width / 2;
				    })
				    .attr("cy", function(d, i) {
				    	return Math.sin(theta(d)) * dist(d) + height / 2;
				    });

			}

			var circle_attrs = circles.attr("cx", function(d) { return d.cx; })
									  .attr("cy", function(d) { return d.cy; })
									  .attr("r", function(d) { return d.r; })
									  .attr("fill", function(d) { return d.color; })
									  .attr('stroke', "#008523")
									  .attr("stroke-width", 2)
									  .on("click", function(d, i) {
									  	filterhops(d);
									  })
									  .on("mouseover", function(d, i) {
										d3.select(this).transition().attr("r", 1.1 * d.r);
										d3.select("#hopname").text(d.name);
									  })
									  .on("mouseout", function(d, i) {
									  	d3.select(this).transition().attr("r", d.r);
									  });
			var alphahops = hop_attrs.concat().sort(function(a, b) { return a.name.localeCompare(b.name); });
			var hoplist = d3.select("body>.vizframe>.choose-hop>.hoplist");
			var list_items = hoplist.on("change", function(){
										var ind = this.selectedIndex;
										if (ind === 0) {
											filterhops(null);
										} else {
									    	filterhops(alphahops[this.selectedIndex - 1]);
									    }
									})
									.selectAll("li.hoption")
									.data(alphahops)
									.enter()
									.append("option")
									.attr("class", "hoption")
									.text(function(d) { return d.name +" (" + d.count + ")"; })
									.attr('value', function(d, i) { return i; });

			d3.select("body>.vizframe>.choose-hop>.reset").on("click", function() { filterhops(null); });
		</script>
	</body>
</html>